var documenterSearchIndex = {"docs":
[{"location":"reduce/#reduce()-1","page":"reduce()","title":"reduce()","text":"","category":"section"},{"location":"reduce/#","page":"reduce()","title":"reduce()","text":"treduce","category":"page"},{"location":"reduce/#ThreadedMap.treduce","page":"reduce()","title":"ThreadedMap.treduce","text":"treduce(op::Function, itr::AbstractArray)\n\nMulti-threaded version of reduce(op, itr). Note that function op must not change type!\n\n\n\n\n\n","category":"function"},{"location":"mapfoldl/#mapfoldl()-1","page":"mapfoldl()","title":"mapfoldl()","text":"","category":"section"},{"location":"mapfoldl/#","page":"mapfoldl()","title":"mapfoldl()","text":"tmapfoldl","category":"page"},{"location":"mapfoldl/#ThreadedMap.tmapfoldl","page":"mapfoldl()","title":"ThreadedMap.tmapfoldl","text":"tmapfoldl(f::Function, op::Function, itr::AbstractArray)::AbstractArray\n\nMulti-threaded version of mapfoldl(f, op, itr). Only the mapping part is parallelised.\n\n\n\n\n\n","category":"function"},{"location":"foreach/#foreach()-1","page":"foreach()","title":"foreach()","text":"","category":"section"},{"location":"foreach/#","page":"foreach()","title":"foreach()","text":"tforeach","category":"page"},{"location":"foreach/#ThreadedMap.tforeach","page":"foreach()","title":"ThreadedMap.tforeach","text":"tforeach(f::Function, c::AbstractArray)::Nothing\n\nMulti-threaded version of foreach(f, c).\n\n\n\n\n\n","category":"function"},{"location":"map/#map()-1","page":"map()","title":"map()","text":"","category":"section"},{"location":"map/#","page":"map()","title":"map()","text":"tmap\ntmap!","category":"page"},{"location":"map/#ThreadedMap.tmap","page":"map()","title":"ThreadedMap.tmap","text":"tmap(f::Function, c::AbstractArray)::AbstractArray\n\nMulti-threaded version of map(f, c).\n\n\n\n\n\n","category":"function"},{"location":"map/#ThreadedMap.tmap!","page":"map()","title":"ThreadedMap.tmap!","text":"tmap!(f::Function, destination::AbstractArray, collection::AbstractArray)::Nothing\n\nMulti-threaded version of map!(f, destination, collection).\n\n\n\n\n\n","category":"function"},{"location":"mapfoldr/#mapfoldr()-1","page":"mapfoldr()","title":"mapfoldr()","text":"","category":"section"},{"location":"mapfoldr/#","page":"mapfoldr()","title":"mapfoldr()","text":"tmapfoldr","category":"page"},{"location":"mapfoldr/#ThreadedMap.tmapfoldr","page":"mapfoldr()","title":"ThreadedMap.tmapfoldr","text":"tmapfoldr(f::Function, op::Function, itr::AbstractArray)::AbstractArray\n\nMulti-threaded version of mapfoldr(f, op, itr). Only the mapping part is parallelised.\n\n\n\n\n\n","category":"function"},{"location":"#ThreadedMap.jl-Documentation-1","page":"Home","title":"ThreadedMap.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package implements Multi-threaded variants of the mapping functions (currently foreach, map, reduce, mapreduce, mapfoldl and mapfoldr) in Julia. See the reference for details about the individual functions provided by this package.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that when using this package, the responsibility for preventing race conditions lies with the user.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Warning: Multi-threading in Julia is an experimental feature, use with caution. Crashes may occur quite frequently and are not caused by this package.","category":"page"},{"location":"mapreduce/#mapreduce()-1","page":"mapreduce()","title":"mapreduce()","text":"","category":"section"},{"location":"mapreduce/#","page":"mapreduce()","title":"mapreduce()","text":"For this function, there are three versions available - tmapreduce, which parallelises only the mapping part (only function f), maptreduce, which parallelises only the reduction part (only function op) and tmaptreduce, which parallelises both.","category":"page"},{"location":"mapreduce/#","page":"mapreduce()","title":"mapreduce()","text":"tmapreduce\nmaptreduce\ntmaptreduce","category":"page"},{"location":"mapreduce/#ThreadedMap.tmapreduce","page":"mapreduce()","title":"ThreadedMap.tmapreduce","text":"tmapreduce(f::Function, op::Function, itr::AbstractArray)\n\nMulti-threaded version of mapreduce(f, op, itr). Only the mapping part is parallelised.\n\n\n\n\n\n","category":"function"},{"location":"mapreduce/#ThreadedMap.maptreduce","page":"mapreduce()","title":"ThreadedMap.maptreduce","text":"maptreduce(f::Function, op::Function, itr::AbstractArray)\n\nMulti-threaded version of mapreduce(f, op, itr). Only the reduction part is parallelised. Note that function op must not change type!\n\n\n\n\n\n","category":"function"},{"location":"mapreduce/#ThreadedMap.tmaptreduce","page":"mapreduce()","title":"ThreadedMap.tmaptreduce","text":"tmaptreduce(f::Function, op::Function, itr::AbstractArray)\n\nMulti-threaded version of mapreduce(f, op, itr). Both the mapping and the reduction part is parallelised. Note that function op must not change type!\n\n\n\n\n\n","category":"function"}]
}
